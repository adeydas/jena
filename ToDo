==== ARQ ToDo

++ ** Document "stages"
++ ** Document "update API"
++ Algebra building src-examples 
++ javadoc-all in the build = 5M of zip.
++ Reorder documentation - intro, SPARQL, extensions.

++ Query compare: expressions
See ToDoSSE
-----
+ insert op write/read test into serialization tests
+ (project ...) and (order ...) are inconsistent

+ GROUP BY
    COUNT(*) done, not COUNT distinct or count(var) or count distinct var
  GROUP BY tests
    Only complete data test done. Need partial versions.
  Query cosistency tests.
    Need to test consistency of variables used at algebra compile time.

+ Remove com.hp.hpl.jena.sparql.function.library.trace
  And any documentation
  Remove FmtExprARQSubst?  What happens in a SPARQL query with RepeatApply of filters? 

+ Sort out FmtExpr (make a proper interface)

+ OpOrder to take an ExprList
+ ExprList writing an LJ

+ Aggregates: QueryIterGroup
  Parsing and serialization done.
  Need OpWriter/Builder update.
  
  Parsing : 
     Phase 2 detects inconsistences
     Check on query compile?

+ SELECT expressions [Impl DONE]
  Document 
  
+ Expression printing : expr.toString should not add outer brackets
  ExprNode.toString => ExprUtils.fmtSPARQL(IndentedWriter, Expr, pmap) => FmtExpr/FmtExprARQ.visit
     Split FmtExpr in statics and a nested visitor. 
 
+ Optimizer 
  
+ Check the better code in QueryIterTriplePattern.TripleMapper 
  Still needs to delay the binding allocation.  
         
+ DateTime arithmetic and durations
  http://www.w3.org/TR/xpath-functions/#dateTime-arithmetic

+ Quads - independent quads?  Or retain blocking structure?

+ Remote update over HTTP

+ testing QE/ref and QE/main in the same run
  ?? use a factory list, including tests with no recorded results.
  ?? Could simply factory to have .create() return null for "no".

+ Initial binding for UpdateRequest

== Core

+ FmtUtils and WriterTriple/Node/...
  NodeToLabel maps.

+ ResultsFormat (output)vs ResultSetFormat (input)
  ResultSetFormatter.oopput as SSE
  ResultSetFactory input as SSE
  rset handler boolean and result set XML forms together => sSPARQLResults.

+ What is "OpDatasetNames" nowadays?
	A table?  unnecessary?
+ Revisit arq.cmd.QueryUtils for printing.

+ Alternative indexes
  LARQ idea - extracted.  Object ==> node/subject
  
+ REDUCED tests :-(

+ Commands
  + qtest to use modules (and qexpr)
    ModVersion
  + qparse to test op output

+ DatasetImpl and DataSourceImpl 
    Revisit.
      
== Algebra

+ OpWalker - only used for getting vars, and that needs to truncate a walk.
+ Left join as "join union diff"
+ Table equals (with and without order)
  
== LARQ

+ LARQ assembler

+ Implement IndexBuilderLiter.unindexStatement

+ LARQ Doc internals
  Fields: index, lex/lang/datatype, uri, bnode

== Documentation

+ list handling as a specific page.
  + Internals
  	Query iterators
  	Bindings

+ Writing filter functions [Done]
+ Writing property functions

+ Document making and using datasets
+ Location-mapping and FROM/FROM NAMED
  
== Other

+ XML results: process xml:lang on other elements than just <literal>
  Documentation for XML result set processing
