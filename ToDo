==== ARQ ToDo

** Clearer ways to add BGP solver mechanisms - invert Stage/StageList 

** Split SELECT into constructive assignments which ar epushed in so visible to ORDER BY.
    Need to move assignments (expressions, which add variables) to before ORDER BY and HAVING
++ ** Document "stages" - new form.
++ ** Document "update API" and examples.

+ Initial binding for UpdateRequest

+ OpService in ref QE.

+  FROM <.....n3>
   but it's application/rdf+xml
   believe MIME type.
   Jena change: FileManager/MimeStream

++ Tutorial on update 
++ ARQ documentation and clearup - adding new storage layers.
   Separate out list PFs like free text.
See ToDoSSE

----

+ OpBGP is (ref- & main-) compiled to a call to static "StageBuilder.compile" (modularity)  
  StageBuilder::
     Choose StageGenerator and calls it to get a StageList
     .build the StageList to a QueryIterator
     Return QueryIterator.
  (Check for StageList.add() calls).
  Maybe:      
     StageGenerator => "Stage" (name reuse?) as a factory-like mechanism
	 StageList is a kind of Stage.       
  Better, better?: do as a Transform, which changes a BGP to a matcher/solver.

+ OpCompiler: have a global factory so that can use QueryEngineMain and supply subclasses 
  of OpCompiler (experimentation and extensibility for Andreas). 

+ Results set to note when finished and warn on attempted continued use.

+ More dateTime arithmetic and durations
  http://www.w3.org/TR/xpath-functions/#dateTime-arithmetic

+ testing QE/ref and QE/main in the same run
  ?? use a factory list, including tests with no recorded results.
  ?? Could simply factory to have .create() return null for "no".

+ OpOrder to take an ExprList 
  Query has a list of sort conditions so need turn SortCondition into an expression

+ ResultsFormat (output)vs ResultSetFormat (input)
  ResultSetFormatter.output as SSE
  ResultSetFactory input as SSE
  rset handler boolean and result set XML forms together => sSPARQLResults.

+ What is "OpDatasetNames" nowadays?
	A table?  unnecessary?
	+ Remove OpDatasetNames?? - only needed in quad compilation for GRAPH ?g {}
  Do that a betetr way (join of all names).
  Special iterator for OpCompiler? 

+ Alternative indexes
  LARQ idea - extracted.  Object ==> node/subject
  
== LARQ

+ LARQ assembler

+ Implement IndexBuilderLiter.unindexStatement

+ LARQ Doc internals
  Fields: index, lex/lang/datatype, uri, bnode

== Documentation

+ list handling as a specific page.
  + Internals
  	Query iterators
  	Bindings

+ Writing filter functions [Done]
+ Writing property functions

+ Document making and using datasets
+ Location-mapping and FROM/FROM NAMED
  
== Other

+ XML results: process xml:lang on other elements than just <literal>
  Documentation for XML result set processing
