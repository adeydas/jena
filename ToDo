==== ARQ ToDo

** Paths 

+ {0} to be an assignment? 
+ ** Path syntax tests (scripted)

+ Precedence-driven printing PathWriter.

+ Check: JoinClassification involving OpSeq
** Stricter rules for property functions - must bind all variables => can do FILTER migration across them.

See ToDoSSE

----
+ Do more at algebra level:
  Reorg to be a algebra -> algebra rewrite.
  OpFilter/OpBGP done as a rewrite to OpSequence/OpFilter/OpBGp
  Direct (flow based) execution in main - remove the FilterPlacement and BGP optimizer to an optimize step. 

+ Stages and FilterPlacement.
	invert Stage/StageList
	Formalse the TDB stacking generator approach.
	  Or even register stage facctories with accept/create 
	
+ extra jar - testing only.

+ Parser context (to put var allocation things in)

+  FROM <.....n3>
   but it's application/rdf+xml
   believe MIME type.
   Jena change: FileManager/MimeStream

+ SUM [done], MIN, MAX, AVG, (STDDEV)
   MINI, MINN, MIND

+ EXISTS { pattern } as FILTER 

+ Tutorial on update 
   Separate out list PFs like free text.

+ Wrapper to have all functions as assignments

[DONE/checked]
  + Ref engine should work on (new style) property functions
    Test failure is due to { pattern LJ propfunc } - fix the property function! 
  + Quad engine - does not do property functions.
  

+ ORDER BY COUNT(*)
  i.e. add to the assignments.
  c.f SELECT
  AlgebraGenerator/compileModifiers(Query, Op)

+ More dateTime arithmetic and durations
  http://www.w3.org/TR/xpath-functions/#dateTime-arithmetic

+ OpOrder to take an ExprList 
  Query has a list of sort conditions so need turn SortCondition into an expression

+ ResultsFormat (output)vs ResultSetFormat (input)
  ResultSetFormatter.output as SSE
  ResultSetFactory input as SSE

+ What is "OpDatasetNames" nowadays?
	A table?  unnecessary?
	+ Remove OpDatasetNames?? - only needed in quad compilation for GRAPH ?g {}
  Do that a better way (join of all names).
  Or even a special iterator for OpCompiler? 

+ Alternative indexes
  LARQ idea - extracted.  Object ==> node/subject
  
== LARQ

+ LARQ assembler

+ Implement IndexBuilderLiter.unindexStatement

+ LARQ Doc internals
  Fields: index, lex/lang/datatype, uri, bnode

== Documentation

+ list handling as a specific page.
  + Internals
  	Query iterators
  	Bindings

== Other

+ XML results: process xml:lang on other elements than just <literal>
  Documentation for XML result set processing
