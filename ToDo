==== ARQ ToDo

ARQ2-beta
+ ** Document "stages"

-----

== Core

+ qexec : no datasets evaluation

+ What is "OpDatasetNames" nowadays?
	A table?  unnecessary?
	
	QueryEngineQuad => Direct from QueryEngineOpBase.
	
	OpExecRef == become a OpExecFactory
	

	Make the Query level separate from the Op level.
	
	QueryEngineOpBase.createQueryIterator(Op) is the downwards.
	Chnage to eval(
	
	
	
	
	QueryEngineBase (not abstract) takes an QueryEngineOp as constructore argument.
	registry is of QueryExecutionOp 
	  QueryEngine registry wraps one in a QueryEngineBase
	QueryEngine1 is legacy only.  ToBeDeleted

  Algebra... has many direct "Op exec" statics.
  Need a registry approach to work with qexec.
  QueryEngineOpBase should not inherit from QueryEngineBase.
  But be an indirection to a QueryEngineOp thing which is (1) graph level and (2) standalone.
  QueryExecution registry fun.

+ Revisit arq.cmd.QuerUtils for printing.

+ Test algebra using BuilderTable etc.

+ A result set is like a table except with (cols)
  ResultsFormat.FMT_SSE!

+ Alternative indexes
  LARQ idea - extracted.  Object ==> node/subject
  
+ REDUCED tests :-(

+ Serilization: 
    redo "prefix" to be SSE compatible.

+ Property function to property path expression

+ Non-distinguished variable removal.
   StageBuilder - strict place
   In a project (or pseudo project) - does it once.
      Need test case : { _:a :p ?v. ?v :splitIRI (?ns ?ln) . _a :p ?w } 
      
+ testing QE1 and QE2 and QE3 in the same test run

+ Commands
  + qtest to use modules (and qexpr)
    ModVersion
  + qexec tidy/integration with qparse/query : need an "op" level.
    Maybe QueryExecutionOp interface.

== Algebra

+ OpWalker  - only used for getting vars, and that needs to truncate a walk.
+ OpExt - is this still workable?
+ Tests
  
== SSE
  Tables as Ops.
  Builder tidying and testing

  Expr: (exists (pattern ...))
  
  (group (vars) aggregate)
  
  Assignment:
  (assign ((?x expr) (?y expr)) --  (:= ?x expr) [is this SELECT/project?]
     (project ...))
     (project (?x ?y (?z expr)) ...)

+ Prefix writing.

== LARQ

+ LARQ assembler

+ LARQ Doc internals
  Fields: index, lex/lang/datatype, uri, bnode

== Documentation

+ Document list handling as a specific page.
  + Internals
  	Query iterators
  	Bindings

+ Writing filter functions [Done]
+ Writing property functions

+ Document making and using datasets
+ Location-mapping and FROM/FROM NAMED
  
== Core

+ XML results: process xml:lang on other elements than just <literal>
  Documentation for XML result set processing
