SDB ToDo list (and general notes)
=================================

+ Freeze API

+ Revisit generating SQL for nested DISTINCT

+ Setting options for testing.
+ Tests for union graphs. 
+ Use cursors for streaming / PostgreSQL

+ StoreLoader => StoreLoaderPlus.

+ DB type tables

+ Per store additional context items

+ Improve Joseki integration.
   Built-in (simple) HTTP from Joseki?
   Or just Joseki+example config.
   Joseki needs 
   
   Canned joseki-config.ttl
     

   sdb:SDBConnection ja:assembler "com.hp.hpl.jena.sdb.assembler.SDBConnectionDescAssembler"
   sdb:Store ja:assembler "com.hp.hpl.jena.sdb.assembler.StoreDescAssembler"
 or 
   a general initializer:
   		implements Assembler 
     sdb:SDB ja:loadClass com.hp.hpl.jena.sdb.SDB

== Pattern table and inference

+ Pattern/Inf tables:
  Data:
    Q: { :s a ?t }  D: :s a :C1 . :s a :C2 .  : SC: (:C1, :C2) => duplicates
    Could reduce the input to exclude :s a :C2.
    But if schema changes?
    Else need SELECT DISTINCT subquery.
  Reduce data?  is there always a minimum?  No - but synthetic?
  Or nested SELECT DISTINCT in SQL.

== Graph Management

  Delete model, Clear model, Create model
    Only load is model exists?
    Check in GraphSDB
  Need a "graph ids" table

== Value tables and FILTERs

+ Value-based hashing
  String version - and have fixed choice of xsd:string or plain string for terms.
  Partial alternative: condition is "T.o = hash1 OR T.o = hash2"

+ ValueTables
  Values and conditions : reactivate condition compilation.
  String value table
    With no URIs, much shorter.
    Full text indexing where available?
  Isolate QC2.insertValueGetter

== Design

+ OpSlice. OpUnion

+ Filters

+ Extensible factories for new layouts
  Related to StoreConfig
  sdb/layoutXXX ; sdb/StoreType ; sdb/store/LayoutType ; sdb/store/StoreFactory

+ Prefixes:  Per graph, not global

+ Per store
  SQLUtils and quoting.
  Id generation
   
+ Tidy DB formatting
    per DB list of column generators (getVarchar, getText etc).

+ SPARQL/Update input and control

== Testing

+ Add query tests :
  /Structure/ { opt ... } JOIN { opt ... } 
  
== Misc

+ canonicalise literals on input?

  + Restrict(Join(A,B)) == Join(A,B,condition)
    In rel algebra, don't push into conditions: do in code generation.
  + Precedence-driven output for SqlExpr // SqlExprGenerateSQL, not lots of nesting.
  + SELECT/one table ==> move constraints out (it's just SPJ)
    Put in a SqlNode optimizer stage, just before generation
      IJ-R-T => IJ(r)-T is done specially 
  + Generalize linearization of InnerJoin-only trees
  + Be careful about code generation and a right complex expression
    Use a SELECT for nested expressions?  generalize from COALESCE code generation.
   
+ QueryEngineSDB has duplication with QueryEngineMain - eliminate!
