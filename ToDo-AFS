SDB ToDo list (and general notes)
=================================

** StoreConfig
   locally cache
   List of tables - all table creation to be noted.
   Prefixes.
** StoreLoader interface
** Subclass loading.
** OpSlice. OpUnion

Why do command intuit the driver class name but test suite does not?

+ Model management
  Need a "graph ids" table
  
+ Prefixes
   Per graph, not global

+ Tidy up and document DBtest
  per DB col types!

+ SPARQL/Update input and control

+ Transactions - cleanup.

+ DatasetStore.hasNonEmptyModel(IRI)

+ Add a formatter option to test if DB setup already

+ canonicalise literals on input?

+ GraphSDB : graph query handler

+ QueryEngineSDB has duplication with QueryEngineMain - eliminate!

+ Pattern/Inf tables:
  Data:
    Q: { :s a ?t }  D: :s a :C1 . :s a :C2 .  : SC: (:C1, :C2) => duplicates
    Could reduce the input to exclude :s a :C2.
    But if schema changes?
    Else need SELECT DISTINCT subquery.
  Reduce data?  is there always a minimum?  No - but synthetic?
  Or nested SELECT DISTINCT in SQL.

+ Store config
    in sdb.ttl // in DB // rebuildable?
    Current description + "features"

+ StoreConnection needs a StoreLayout indirection ??
  Connection -> Config "StoreControl" -> Store 
  Store hasA "StoreControl" -- c.f. StoreFormatter
   Features play into this

+ Prefixes : disable for ModelRDB only.
  Done?? Check

+ Prepared statement query cache?
  When will it be beneficial - GraphSDB and add/delete single triples?

+ Value-based hashing
  String version - and have fixed choice of xsd:string or plain string for terms.
  Partial alternative: condition is "T.o = hash1 OR T.o = hash2"

+ Generating SQL:
  + Restrict(Join(A,B)) == Join(A,B,condition)
    In rel algebra, don't push into conditions: do in code generation.
  + Precedence-driven output for SqlExpr // SqlExprGenerateSQL, not lots of nesting.
  + SELECT/one table ==> move constraints out (it's just SPJ)
    Put in a SqlNode optimizer stage, just before generation
      IJ-R-T => IJ(r)-T is done specially 
  + Generalize linearization of InnerJoin-only trees
  + Be careful about code generation and a right complex expression
    Use a SELECT for nested expressions?  generalize from COALESCE code generation.
   

+ Add query tests :
  /Structure/ { opt ... } JOIN { opt ... } 
  
+ ValueTables
  Values and conditions : reactivate condition compilation.
  String value table
    With no URIs, much shorter.
    Full text indexing where available?
  Isolate QC2.insertValueGetter
