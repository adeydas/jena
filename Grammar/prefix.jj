// SPARQL Abstract Grammar
// Author:  Andy Seaborne andy.seaborne@hp.com
// (c) 2006, 2007 Hewlett-Packard Development Company, LP
// All rights reserved.
// See end of file for details.

options
{
  JAVA_UNICODE_ESCAPE   = true;
  UNICODE_INPUT         = false ;
  STATIC                = false ;
//  DEBUG_PARSER          = true ;
//  DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(PrefixParser)
/*
 * (c) Copyright 2006, 2007 Hewlett-Packard Development Company, LP
 * All rights reserved.
 */

package com.hp.hpl.jena.sparql.lang.prefix ;

import com.hp.hpl.jena.graph.* ;
import com.hp.hpl.jena.query.* ;
import com.hp.hpl.jena.sparql.syntax.* ;
import com.hp.hpl.jena.sparql.expr.* ;

public class PrefixParser extends PrefixParserBase
{
}
PARSER_END(PrefixParser)

void CompilationUnit(): { }
{
  Query() <EOF>
}

void Query() : { }
{
  <LPAREN> <QUERY>
  Prolog()
  <LPAREN>
  ( SelectQuery() | ConstructQuery() | DescribeQuery() | AskQuery() )
  <RPAREN>
  
  SolutionModifier()
  ( LOOKAHEAD(2) DatasetClause() )*
  (WhereClause())?
  <RPAREN>
}

void Prolog() : {}
{
  ( LOOKAHEAD(2) BaseDecl() ) ?
  ( LOOKAHEAD(2) PrefixDecl() )*
}

void BaseDecl() : { String iri ; }
{
  <LPAREN>
  <BASE> iri = IRI_REF()
  { getQuery().setBaseURI(iri) ; }
  <RPAREN>
}

void PrefixDecl() : { Token t ; String iri ; }
{
  <LPAREN>
    <PREFIX> t = <PNAME_NS> iri = IRI_REF()
      { String s = fixupPrefix(t.image, t.beginLine, t.beginColumn) ;
        getQuery().setPrefix(s, iri) ; }
  <RPAREN>
}

// ---- Query type clauses

void SelectQuery() : { Node v ; Token t = null ;}
{ 
  <SELECT>
    { getQuery().setQuerySelectType() ; }
  (<LPAREN> 
     <DISTINCT> 
     ( <TRUE>
       { getQuery().setDistinct( true ) ; }
     |
      <FALSE>
       { getQuery().setDistinct( false ) ; }
     )
    <RPAREN> 
  )? 
  (
    ( v = Var() { getQuery().addResultVar(v) ; } )+
    { getQuery().setQueryResultStar(false) ; }
  |
    <STAR> { getQuery().setQueryResultStar(true) ; }
  )
}

void ConstructQuery() : { Template t ; }
{
  <CONSTRUCT>
    { getQuery().setQueryConstructType() ;
      setInConstructTemplate(true) ; }
  t = ConstructTemplate() 
    { setInConstructTemplate(false) ;
      getQuery().setQueryResultStar(false) ;
      getQuery().setConstructTemplate(t) ; }
}

void DescribeQuery() : { Node n ; }
{
  <DESCRIBE>
    { getQuery().setQueryDescribeType() ; }
  (
    ( n = VarOrIRIref() { getQuery().addDescribeNode(n) ; } )+
    { getQuery().setQueryResultStar(false) ; }
  |
    <STAR>
    { getQuery().setQueryResultStar(true) ; }
  )
}

void AskQuery() : {}
{
  <ASK> { getQuery().setQueryAskType() ; }
}

// ----

void DatasetClause() : {}
{
  <LPAREN>
  <FROM>
  ( DefaultGraphClause() | NamedGraphClause() )
  <RPAREN>
}

void DefaultGraphClause() : { String iri ; }
{
  iri = SourceSelector() 
  { getQuery().addGraphURI(iri) ; }
}

void NamedGraphClause() : { String iri ; }
{
  <NAMED>
  iri = SourceSelector()
  { getQuery().addNamedGraphURI(iri) ; }
}

String SourceSelector() : { String iri ; }
{
   iri = IRIref() { return iri ; }
}


void WhereClause() : { Element el ; }
{
   //(<WHERE>)? 
   el = GraphPattern() { getQuery().setQueryPattern(el) ; }
}

// Order, projection, distinct, offset, limit
// Not projection here.

void SolutionModifier() : { }
{
  ( LOOKAHEAD(2) OrderClause() )*
  ( LOOKAHEAD(2) DistinctClause() )?
  ( LOOKAHEAD(2) LimitOffsetClause() )?
}

void LimitOffsetClause() : {}
{
  ( LOOKAHEAD(2)
    LimitClause() (LOOKAHEAD(2) OffsetClause())? 
  |
    OffsetClause() (LOOKAHEAD(2) LimitClause())? 
  )
}

void DistinctClause() : {}
{   
    <LPAREN>
    <DISTINCT> 
    ( <TRUE>
      { getQuery().setDistinct( true ) ; }
    |
      <FALSE>
      { getQuery().setDistinct( false ) ; }
    )
    <RPAREN>
}

void OrderClause() : { }
{
  <LPAREN>
  <ORDER> <BY> OrderCondition()
  <RPAREN>
}

void OrderCondition() :
{ int direction = 0 ; Expr expr = null ; Node v = null ; }
{
  { direction = Query.ORDER_DEFAULT ; }
   ( <ASC>  { direction = Query.ORDER_ASCENDING ; }
   | <DESC> { direction = Query.ORDER_DESCENDING ; }
   )?
   expr = P_Expression()
   { getQuery().addOrderBy(expr, direction) ; }
}

void LimitClause() : { Token t ; }
{
  <LPAREN>
  <LIMIT> t = <INTEGER>
    { getQuery().setLimit(integerValue(t.image)) ; }
  <RPAREN>
}

void OffsetClause() : { Token t ; }
{
  <LPAREN>
  <OFFSET> t = <INTEGER>
    { getQuery().setOffset(integerValue(t.image)) ; }
  <RPAREN>
}

// ---- General Graph Pattern 

Element GraphPattern() : { Element el = null ; Expr c = null ; }
{
 <LPAREN>
 (
   el = BasicGraphPattern()
 | 
   c = Constraint() { el = new ElementFilter(c) ; }
 |
   el = OptionalGraphPattern()
 | 
   el = GroupGraphPattern()
 |
   el = UnionGraphPattern()
 |
   el = GraphGraphPattern()
 |
   el = UnsaidGraphPattern()
)
 <RPAREN>
    { return el ; }
}

Element GroupGraphPattern() : { Element el ; }
{
    { ElementGroup elg = new ElementGroup() ; }
  <GROUP>
    ( el = GraphPattern()
       { elg.addElement(el) ; }
    )*
    {return elg ; }
}

Element BasicGraphPattern() :
  { ElementTriplesBlock bgp = new ElementTriplesBlock() ;
    Triple t ; }
{
    <BASICGRAPHPATTERN>
    { startBasicGraphPattern() ; }
    ( 
      <LPAREN>
      t = TriplePattern() 
          { bgp.addTriple(t) ; }
      <RPAREN>
    )*
    { endBasicGraphPattern() ; }
    { return bgp ; }
}

Triple TriplePattern() : { Node s , p , o ; }
{
    <TRIPLEPATTERN>
    s = VarOrTerm()
    p = VarOrIRIref()
    o = VarOrTerm()
    { return new Triple(s, p, o) ; }
}

Element OptionalGraphPattern() : 
    { Element el = null ; }
{ 
   <OPTIONAL>
     el = GraphPattern()
    { return new ElementOptional(el) ; }
}

Element GraphGraphPattern() : { Element el ; Node n ;}
{ 
  <GRAPH> 
    n = VarOrIRIref()
    el = GraphPattern()
    { return new ElementNamedGraph(n, el) ; }
}

Element UnionGraphPattern() : { ElementUnion el = null ; Element el2 = null ; }
{
  <UNION> 
    { el = new ElementUnion() ; }
    ( el2 = GraphPattern() 
      { el.addElement(el2) ; }
    ) *
    { return el ; }
}

Element UnsaidGraphPattern() : { Element el ; }
{
  <UNSAID>
    el = GraphPattern()
    { return new ElementUnsaid(el) ; }
}

Expr Constraint() : { Expr c ; }
{
  <FILTER>
    c = P_Expression() { return c ; }
}

// -------- Construct patterns

Template ConstructTemplate() : 
{ TemplateGroup g = new TemplateGroup() ; 
  Triple t ;
}
{
  <LPAREN> <TEMPLATEGROUP>
  (
    <LPAREN>
    t = TriplePattern() 
      { g.addTriple(t) ; }
    <RPAREN>
  )*
  <RPAREN>
    { return g ; }
}

// -------- Prefix expressions

Expr P_Expression() : {  Expr e ; Node n ; }
{
  <LPAREN>
    e = P_GeneralFunctionCall()
  <RPAREN>
   { return e ; }
| 
    n = VarOrTerm()
    { return asExpr(n) ; } 
}

Expr P_GeneralFunctionCall() : {Expr n1 = null; Expr n2 = null ; Expr e ; Node n ; }
{
  <EQ> n1 = P_Expression() n2 = P_Expression()
    { return new E_Equals(n1,n2) ; }
|
  <NE> n1 = P_Expression() n2 = P_Expression()
    { return new E_NotEquals(n1,n2) ; }
|
  <GT> n1 = P_Expression() n2 = P_Expression()
    { return new E_GreaterThan(n1,n2) ; }
|
  <LT> n1 = P_Expression() n2 = P_Expression()
    { return new E_LessThan(n1,n2) ; }
|
  <LE> n1 = P_Expression() n2 = P_Expression()
    { return new E_LessThanOrEqual(n1,n2) ; }
|
  <GE> n1 = P_Expression() n2 = P_Expression()
    { return new E_GreaterThanOrEqual(n1,n2) ; }
|
  <SC_OR> n1 = P_Expression() n2 = P_Expression()
    { return new E_LogicalOr(n1,n2) ; } 
|
  <SC_AND> n1 = P_Expression() n2 = P_Expression()
    { return new E_LogicalAnd(n1,n2) ; }
|
    // Unary versions needed
  <PLUS> n1 = P_Expression() ( n2 = P_Expression() )?
    { if (n2 == null) return new E_UnaryPlus(n1) ;
      return  new E_Add(n1, n2) ; }
|
  <MINUS> n1 = P_Expression() ( n2 = P_Expression() )?
    { if (n2 == null) return new E_UnaryMinus(n1) ;
      return new E_Subtract(n1, n2) ; }
|
  <STAR> n1 = P_Expression() n2 = P_Expression()
    { return new E_Multiply(n1, n2) ; }
|
  <SLASH> n1 = P_Expression() n2 = P_Expression()
    { return new E_Divide(n1, n2) ; }
|
  <BANG> e = P_Expression()
    { return new E_LogicalNot(e) ; }
| 
   e = P_Function() { return e ; }
|
  <EXPR> e = Expression() { return e ; }
}

Expr P_Function() : { Expr e ; String fname ; ExprList a ; }
{
  e = P_BuiltInCall() { return e ; }
|
  fname = IRIref() a = P_ArgList()
    { return new E_Function(fname, a) ; }  
}

ExprList P_ArgList() : { Expr expr ;  ExprList args = new ExprList() ; }
{ 
      (expr = P_Expression() { args.add(expr) ; } )*
    { return args ; }
}

Expr P_BuiltInCall() : { Expr expr , expr1 , expr2 ; Node gn ; }
{
  <STR>
    expr = P_Expression()
    { return new E_Str(expr) ; }
|
  <LANG>
    expr = P_Expression()
    { return new E_Lang(expr) ; }
|
  <LANGMATCHES> 
    expr1 = P_Expression() 
    expr2 = P_Expression()
    { return new E_LangMatches(expr1, expr2) ; }
|
  <SAME_TERM> 
    expr1 = P_Expression() 
    expr2 = P_Expression()
    { return new E_SameTerm(expr1, expr2) ; }
|
    <DTYPE>
    expr = P_Expression()
    { return new E_Datatype(expr) ; }
| 
  <BOUND>
    gn = Var()
    { return new E_Bound(new NodeVar(gn)) ; }
| 
  <IS_IRI> expr = P_Expression()
    { return new E_IsIRI(expr) ; }

| <IS_URI> expr = P_Expression()
    { return new E_IsURI(expr) ; }

| <IS_BLANK> expr = P_Expression()
    { return new E_IsBlank(expr) ; }

| <IS_LITERAL> expr = P_Expression()
   { return new E_IsLiteral(expr) ; }

| // Regular expression matcher
    expr = P_RegexExpression() { return expr ; }
}

Expr P_RegexExpression() :
{ Expr expr ; Expr patExpr = null ; Expr flagsExpr = null ; }
{
    <REGEX>
      expr = P_Expression() 
      patExpr = P_Expression()
      ( flagsExpr = P_Expression() ) ?
      { return new E_Regex(expr, patExpr, flagsExpr) ; }
}

// -------- Expression syntax : algebraic form

Expr Expression() : { Expr n ; }
{
  n = ConditionalOrExpression()
  { return n ; }
}

Expr ConditionalOrExpression() : { Expr n1, n2 ; }
{
  n1 = ConditionalAndExpression() 
  ( <SC_OR> n2 = ConditionalAndExpression()
    { n1 = new E_LogicalOr(n1,n2) ; } 
  )*
    { return n1 ; }
    
}

Expr ConditionalAndExpression() : { Expr n1, n2 ;}
{
  n1 = ValueLogical()
  ( <SC_AND> n2 = ValueLogical()
    { n1 = new E_LogicalAnd(n1,n2) ; }
  )*
    { return n1 ; }
}

Expr ValueLogical() : { Expr n ; }
{
  n = RelationalExpression()
    { return n ; }
}

Expr RelationalExpression() : { Expr n1, n2 ; }
{
  n1 = NumericExpression()
  (
    <EQ> n2 = NumericExpression()
      { n1 = new E_Equals(n1,n2) ; }
  | <NE> n2 = NumericExpression()
      { n1 = new E_NotEquals(n1,n2) ; }
  | <LT> n2 = NumericExpression()
      { n1 = new E_LessThan(n1,n2) ; }
  | <GT> n2 = NumericExpression()
      { n1 = new E_GreaterThan(n1,n2) ; }
  | <LE> n2 = NumericExpression()
      { n1 = new E_LessThanOrEqual(n1,n2) ; }
  | <GE> n2 = NumericExpression()
      { n1 = new E_GreaterThanOrEqual(n1,n2) ; }
  )?
    { return n1 ; }
}

Expr NumericExpression ()  : { Expr n ; }
{
  n = AdditiveExpression()
    { return n ; }
}

Expr AdditiveExpression() : { Expr n1,n2 ; }
{
  n1 = MultiplicativeExpression()
  ( <PLUS> n2 = MultiplicativeExpression()
    { n1 = new E_Add(n1, n2) ; }
  | <MINUS> n2 = MultiplicativeExpression()
    { n1 = new E_Subtract(n1, n2) ; }
  )*
    { return n1 ; }
}

Expr MultiplicativeExpression() : { Expr n1,n2 ; }
{
  n1 = UnaryExpression()
  ( <STAR>  n2 = UnaryExpression()
    { n1 = new E_Multiply(n1, n2) ; }
  | <SLASH> n2 = UnaryExpression()
    { n1 = new E_Divide(n1, n2) ; }
//   | <REM>   n2 = UnaryExpression()
//     { n1 = new E_Modulus(n1, n2) ; }
  )*
    { return n1 ; }
}

Expr UnaryExpression() : { Expr n ; }
{
  <BANG> n = PrimaryExpression()
    { return new E_LogicalNot(n) ; }
  | <PLUS>  n = PrimaryExpression() { return new E_UnaryPlus(n) ; }
  | <MINUS> n = PrimaryExpression() { return new E_UnaryMinus(n) ; }
  | n = PrimaryExpression() { return n ; }
}

Expr PrimaryExpression() : { Expr expr ; Node gn ; }
{
  ( expr = BrackettedExpression() { return expr ; }
  | expr = BuiltInCall() { return expr ; }  
  | expr = IRIrefOrFunction()  { return expr ; }

// NOT  | gn = VarOrTerm()           { return asExpr(gn) ; }
// Because of IRIrefOrFunction vs <NIL>
// and because of signhandling (which is done 
// with unary ops in expressions.
  | gn = RDFLiteral()      { return asExpr(gn) ; }
  | gn = NumericLiteral()  { return asExpr(gn) ; }
  | gn = BooleanLiteral()  { return asExpr(gn) ; }
//  | gn = BlankNode()       { return asExpr(gn) ; }
  | gn = Var()             { return asExpr(gn) ; }
  )
}

Expr BrackettedExpression() : { Expr expr ; }
{
    <LPAREN> expr = Expression() <RPAREN>  { return expr ; }
}

Expr BuiltInCall() : { Expr expr ; Expr expr1, expr2 ; Node gn ; Token t ;}
{
    // STR
    <STR> <LPAREN> expr = Expression() <RPAREN>
    { return new E_Str(expr) ; }
//   | 
//     // URI
//     <URI> <LPAREN> expr = Expression() <RPAREN>
//     { return new E_Str(expr) ; }
  | // Lang
    <LANG> <LPAREN> expr = Expression() <RPAREN>
    { return new E_Lang(expr) ; }
  |// Langmatches
    <LANGMATCHES> 
       <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new E_LangMatches(expr1, expr2) ; }

  | // Datatype
    <DTYPE> <LPAREN> expr = Expression() <RPAREN>
    { return new E_Datatype(expr) ; }

  | <BOUND> <LPAREN> gn = Var() <RPAREN>
    { return new E_Bound(new NodeVar(gn)) ; }

  | <SAME_TERM> <LPAREN> expr1 = Expression() <COMMA> expr2 = Expression() <RPAREN>
    { return new E_SameTerm(expr1, expr2) ; }

  | t = <IS_IRI> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsIRI(expr) ; }

  | t = <IS_URI> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsURI(expr) ; }

  | <IS_BLANK> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsBlank(expr) ; }

  | <IS_LITERAL> <LPAREN> expr = Expression() <RPAREN>
    { return new E_IsLiteral(expr) ; }

  | // Regular expression matcher
    expr = RegexExpression() { return expr ; }
}

Expr RegexExpression() :
{ Expr expr ; Expr patExpr = null ; Expr flagsExpr = null ; }
{
    <REGEX> <LPAREN> 
      expr = Expression() 
      <COMMA>
      patExpr = Expression()
      ( <COMMA> flagsExpr = Expression() ) ?
    <RPAREN>
      { return new E_Regex(expr, patExpr, flagsExpr) ; }
}

Expr FunctionCall() : { String fname ; ExprList a ; }
{
  fname = IRIref() a = ArgList()
    { return new E_Function(fname, a) ; }
}

ExprList ArgList() : { Expr expr ;  ExprList args = new ExprList() ; }
{ 
  (
    <NIL>
  |
   // Was <LPAREN> ( Expression() (<COMMA> Expression() )* )? <RPAREN>
    <LPAREN> 
      expr = Expression() { args.add(expr) ; } 
      (<COMMA> expr = Expression() { args.add(expr) ; } )*
    <RPAREN>
   )
    { return args ; }
}


// The case of "q:name()" or just "q:name"
// by expanding out FunctionCall()

Expr IRIrefOrFunction() : {String iri ; ExprList a = null ; }
{
  iri = IRIref()
  ( a = ArgList() )?
    { if ( a == null ) return asExpr(createNode(iri)) ;
      return new E_Function(iri, a) ;
    }
}

// ---- Basic terms

Node VarOrIRIref() : {Node n = null ; String iri ; }
{
  ( n = Var() | iri = IRIref() { n = createNode(iri) ; } )
  { return n ; }
} 

// Node VarOrBlankNodeOrIRIref() : {Node n = null ; }
// {
//   ( n = Var() | n = BlankNode() | n = IRIref() )
//   { return n ; }
// }


Node VarOrTerm() : {Node n = null ; }
{
  ( n = Var() | n = GraphTerm() )
  { return n ; }
}

Node Var() : { Token t ;}
{
    ( t = <VAR1> | t = <VAR2> )
    { return createVariable(t.image, t.beginLine, t.beginColumn) ; }
}
Node GraphTerm() : { Node n ; String iri ; }
{
  iri = IRIref()          { return createNode(iri) ; }
| 
  n = RDFLiteral()      { return n ; }
|
  n = NumericLiteral()  { return n ; }
|
  n = BooleanLiteral()  { return n ; }
|
  n = BlankNode()       { return n ; }   
|
//  <LPAREN> <RPAREN>     { return nRDFnil ; }
  <NIL>  { return nRDFnil ; }
}


Node RDFLiteral() : { Token t ; String lex = null ; }
{
  lex = String()
  // Optional lang tag and datatype.
  { String lang = null ; String iri = null ; }
  (
    ( t = <LANGTAG>  { lang = stripChars(t.image, 1) ; } )
  |
    ( <DATATYPE> iri = IRIref() )
  )?
    { return createLiteral(lex, lang, iri) ; }
} 

Node NumericLiteral() : { Token t ; }
{
  t = <INTEGER> { return createLiteralInteger(t.image) ; }
| t = <DECIMAL> { return createLiteralDecimal(t.image) ; }
| t = <DOUBLE>  { return createLiteralDouble(t.image) ; }
}

Node BooleanLiteral() : {}
{
  <TRUE> { return XSD_TRUE ; }
 |
  <FALSE> { return XSD_FALSE ; }
}



String String() : { Token t ; }
{
  ( t = <STRING_LITERAL1>
  | t = <STRING_LITERAL2>
  | t = <STRING_LITERAL_LONG1>
  | t = <STRING_LITERAL_LONG2>
  )
    { String lex = stripQuotes(t.image) ; 
      lex = unescapeStr(lex,  t.beginLine, t.beginColumn) ;
      return lex ;
    }
}

String IRIref() : { String iri ; }
{
  iri = IRI_REF() { return iri ; }
|
  iri = PrefixedName() { return iri ; }
}

String PrefixedName() : { Token t ; }
{
  ( t = <PNAME_LN>
    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  |
    t = <PNAME_NS>
    { return resolvePName(t.image, t.beginLine, t.beginColumn) ; }
  )
}

Node BlankNode() :  { Token t = null ; }
{
  t = <BLANK_NODE_LABEL>
    { return createBNode(t.image, t.beginLine, t.beginColumn) ; }  
|
//  <LBRACKET> <RBRACKET> { return createBNode() ; }
  <ANON> { return createBNode() ; }

}

String IRI_REF() : { Token t ; }
{
  t = <IRIref>
  { return resolveQuotedIRI(t.image, t.beginLine, t.beginColumn) ; }
}

// ------------------------------------------
// Tokens

// Comments and whitespace

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

TOKEN: { <#WS: " " | "\t" | "\n" | "\r" | "\f"> }

SPECIAL_TOKEN :
{ <SINGLE_LINE_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }

// Main tokens */

TOKEN:
{
   // Includes # for relative URIs
   <IRIref: "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`", 
                      "\u0000"-"\u0020"])* ">" >
|  <PNAME_NS: (<PN_PREFIX>)? ":" >
|  <PNAME_LN: <PNAME_NS> <PN_LOCAL> >
|  <BLANK_NODE_LABEL: "_:" <PN_LOCAL> >
|  <VAR1: "?" <VARNAME> >
|  <VAR2: "$" <VARNAME> >
|  <LANGTAG: <AT> (<A2Z>)+("-" (<A2ZN>)+)* >
|  <#A2Z: ["a"-"z","A"-"Z"]>
|  <#A2ZN: ["a"-"z","A"-"Z","0"-"9"]>
}

// -------------------------------------------------
// Keyworks : includes operators that are words and should be
// before general things like IDENTIFIER which swallow almost
// anything

TOKEN : { <KW_A:  "a" > } // Before HEX rule!

TOKEN [IGNORE_CASE] :
{
   < QUERY:       "query" >
// Prologue
|  < BASE:        "base" >
|  < PREFIX:      "prefix" >

// Result forms
|  < SELECT:      "select" >
|  < DISTINCT:    "distinct" >
|  < DESCRIBE:    "describe" >
|  < CONSTRUCT:   "construct" >
|  < ASK:         "ask" >

|  < LIMIT:       "limit" >
|  < OFFSET:      "offset" >
|  < ORDER:       "order" >
|  < BY:          "by" >

|  < AS:          "as" >
|  < ASC:         "asc" >
|  < DESC:        "desc" >

// Dataset
|  < NAMED:       "named" >
|  < FROM:        "from" >

// Graph pattern operators 
// |  < WHERE:       "where" >
// |  < AND:         "and" >
|  < TEMPLATEGROUP:      "templategroup" >
// |  < TRIPLETEMPLATE:    "tripletemplate" >
|  < TRIPLEPATTERN:     "triplepattern" >
|  < BASICGRAPHPATTERN: "basicgraphpattern" >
|  < GROUP:         "group" >


|  < GRAPH:       "graph" >
|  < OPTIONAL:    "optional" >
|  < UNION:       "union" >
|  < UNSAID:      "unsaid" >
|  < FILTER:      "filter" >
|  < EXPR:        "expr" >

// Expression operators
|  < BOUND:       "bound" >
|  < STR:         "str" >
|  < DTYPE:       "datatype" >
|  < LANG:        "lang" >
|  < LANGMATCHES: "langmatches" >
|  < IS_URI:      "isURI" >
|  < IS_IRI:      "isIRI" >
|  < IS_BLANK:    "isBlank" >
|  < IS_LITERAL:  "isLiteral" >
|  < REGEX:       "regex" >
|  < SAME_TERM:   "sameTerm" >

|  <TRUE:         "true" >
|  <FALSE:        "false" >
}

// -------------------------------------------------

TOKEN :
{
   < INTEGER: (["-","+"])? <DIGITS> >
|
   < DECIMAL: (["-","+"])? (<DIGITS>)+ "." (<DIGITS>)* | "." (<DIGITS>)+ >
      // Required exponent.
|  < DOUBLE:
      (["+","-"])?
      (["0"-"9"])+ "." (["0"-"9"])* <EXPONENT>
      | "." (["0"-"9"])+ (<EXPONENT>)
      | (["0"-"9"])+ <EXPONENT>
      >

// | < INTEGER_POSITIVE: <PLUS> <INTEGER> >
// | < DECIMAL_POSITIVE: <PLUS> <DECIMAL> >
// | < DOUBLE_POSITIVE:  <PLUS> <DOUBLE> >
// 
// | < INTEGER_NEGATIVE: <MINUS> <INTEGER> >
// | < DECIMAL_NEGATIVE: <MINUS> <DECIMAL> >
// | < DOUBLE_NEGATIVE:  <MINUS> <DOUBLE> >

   // Optional exponent.
// |  < DOUBLE:
//       //(["+","-"])?
//       (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
//       | "." (["0"-"9"])+ (<EXPONENT>)?
//       | (["0"-"9"])+ <EXPONENT>
//       >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < #QUOTE_3D: "\"\"\"">
| < #QUOTE_3S: "'''">

| <ECHAR: "\\" ( "t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'") >

| < STRING_LITERAL1: 
      // Single quoted string
      "'" ( (~["'","\\","\n","\r"]) | <ECHAR> )* "'" > 

| < STRING_LITERAL2:
    // Double quoted string
      "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> )* "\"" >

| < STRING_LITERAL_LONG1:
     <QUOTE_3S> 
      ( ("'" | "''")? (~["'","\\"] | <ECHAR> ))*
     <QUOTE_3S> >

| < STRING_LITERAL_LONG2: 
     <QUOTE_3D> 
      ( ("\"" | "\"\"")? (~["\"","\\"] | <ECHAR> ))*
     <QUOTE_3D> >
| < DIGITS: (["0"-"9"])+>
| <HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
}

TOKEN :
{
  < LPAREN:    "(" >
| < RPAREN:    ")" >

// I don't know why white space is needed to be included here but not ANON
| <NIL: <LPAREN> (<WS>)* <RPAREN> >

| < LBRACE:    "{" >
| < RBRACE:    "}" >

| < LBRACKET:  "[" >
| < RBRACKET:  "]" >
// (<WS>)* is not needed but is in NIL
| < ANON:      <LBRACKET> (<WS>)* <RBRACKET> >

| < SEMICOLON: ";" >
| < COMMA:     "," >
| < DOT:       "." >
}

// Operator

TOKEN :
{
  < EQ:      "=" >
| < NE:      "!=" >
| < GT:      ">" >
| < LT:      "<" >
| < LE:      "<=" >    // Maybe: | "=>" >
| < GE:      ">=" >    // Maybe: | "=<" >

| < BANG:    "!" >
| < TILDE:   "~" >
| < COLON:   ":" >

| < SC_OR:   "||" >
| < SC_AND:  "&&" >

| < PLUS:    "+" >
| < MINUS:   "-" >
| < STAR:    "*" >
| < SLASH:   "/" >

//| < AMP: "&" >
//| < REM: "%" >

| < DATATYPE: "^^">
| < AT: "@">
}

TOKEN:
{
  // XML 1.1 NCNameStartChar without "_"
  <#PN_CHARS_BASE:
          ["A"-"Z"] | ["a"-"z"] |
          ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] |
          ["\u0370"-"\u037D"] | ["\u037F"-"\u1FFF"] |
          ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"] |
          ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFFFD"] 
          >
          // [#x10000-#xEFFFF]
|
  <#PN_CHARS_U: <PN_CHARS_BASE> | "_" >
|
// No DOT
  <#PN_CHARS: (<PN_CHARS_U> | "-" | ["0"-"9"] | "\u00B7" |
              ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] ) >
|
  // No leading "_", no trailing ".", can have dot inside prefix name.
  <#PN_PREFIX: <PN_CHARS_BASE> ((<PN_CHARS>|".")* <PN_CHARS>)?  >
|
  // With a leading "_", no dot at end of local name.
  <#PN_LOCAL: (<PN_CHARS_U> | ["0"-"9"]) ((<PN_CHARS>|".")* <PN_CHARS>)?  >
|
  // NCNAME without "-" and ".", allowing leading digits.
  <#VARNAME: ( <PN_CHARS_U> | ["0"-"9"] )
             ( <PN_CHARS_U> | ["0"-"9"] | "\u00B7" |
               ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"] )* >
}

// Catch-all tokens.  Must be last.  
// Any non-whitespace.  Causes a parser exception, rather than a
// token manager error (with hidden line numbers).
// Only bad IRIs (e.g. spaces) now give unhelpful parse errors.
TOKEN:
{
  <#UNKNOWN: (~[" ","\t","\n","\r","\f" ])+ >
}

/*
 * (c) Copyright 2004, 2005, 2006, 2007 Hewlett-Packard Development Company, LP
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
